<h2>Choose Your Node Adventure</h2>

<p>
  Adventure gamebooks, like the <i>Fighting Fantasy</i> series or <i>Choose Your Own Adventure</i> books, are written
  as a bunch of scenes which, if read in the order printed, make no sense. Each is a scene in the narrative that YOU, 
  the reader, are currently playing out, and ends with a list of choices for the next section to read, representing 
  the consequences of the action described and/or the reactions you can make in response. When read as intended,
  starting with the first section then choosing your path, an interactive story unfolds where YOU are the hero. You
  succeed or fail based on your actions; the story is decided by your choices. 
</p>

<p>
  The books are always moving forward from choice to choice towards one of several endings, though in some rare
  occasions adventurers may have to return to previous scenes and make different choices to progress. The more 
  advanced kind spice things up by adding RPG mechanics into the mix. They range from the simple and limited to just 
  one book or adventure, such as the main <i>Fighting Fantasy</i> series, to the complex and multi-book spanning like 
  in the <i>Lone Wolf</i> or <i>Sorcery!</i> books. These mechanics are usually implemented using a simple stat system,
  like <strong>SKILL</strong>, <strong>STAMINA</strong>, and <strong>LUCK</strong> in the worlds of
  <i>Fighting Fantasy</i>. The scores can fluctuate during and between adventures, and can be supplemented by finding
  items like enchanted weapons or potions of healing.
</p>

<p>
  Gamebooks reached their peak of popularity in the 80's, after which computers had caught up and were able
  to render these kinds of adventures not just as bare console text, but with actual graphics and mechanics that you
  didn't have to keep track of yourself. There has been a slight comeback, with new titles added to the
  <i>Fighting Fantasy</i> series in the last few years; but their moment has gone. The idea behind them, however, lives
  on. The creator of the popular <i>Dark Souls</i> games Hidetaka Miyazaki has cited <i>Fighting Fantasy</i> as a major
  influence on his work, and his work is often compared to gamebooks for their interconnectedness and difficulty. The 
  genre has become a staple of modern gaming, with many developers taking inspiration from its mechanics and design 
  philosophy. The genre has also spawned a number of imitators, with many games attempting to capture the same sense of
  challenge and exploration that defines the genre.
</p>

<p>
  This format is not limited to pen &amp; paper, nor is it confined to gaming; there are interactive short stories like 
  <i>The Garden of Forking Paths</i> by Jorge Luis Borges; programmed learning materials like the <i>TutorText</i> 
  series and <i>Bandersnatch</i> - the Choose Your Own Episode of Netflix's <i>Black Mirror</i> written by Charlie 
  Brooker. A basic website also works, in some ways, like a gamebook. The user navigates the website like an adventurer
  delving the depths of <i>Deathtrap Dungeon</i>. Instead of fighting monsters and overcoming traps, they must battle
  with adverts and answer cookie policy preferences. Each page of the site contains text and links to other pages,
  just like how each scene in a gamebook leads to other scenes. The structure shared by all these examples is known 
  as a graph, and fortunately for us there is a theory that describes them and how they work.
</p>

<h2>Graph Theory</h2>

<p>
  Graph Theory is a branch of mathematics and computer science that studies the properties and applications of graphs.
  To begin, let's clarify some of the terminology:
</p>

<ul>
  <li>
    A <strong>graph</strong> models the relationships between a collection of nodes. Examples of graphs include; 
    websites; adventure gamebooks; social networks; transportation systems and even the Internet.
  </li>

  <li>
    <strong>Nodes</strong> (also called vertices) are the fundamental units in graph theory, representing entities or 
    points that can be connected to other nodes. In the context of adventure gamebooks, nodes represent the individual
    scenes in the narrative that players experience; in a website, each page is a node in the site's graph. 
  </li>

  <li>
    <strong>Edges</strong> are the relationships between nodes, which connect the nodes and define how they interact with
    each other. These are hyperlinks on a page or choices in a gamebook scene.
  </li>

  <li>
    Graphs can be <strong>directed</strong> or <strong>undirected</strong>, with a directed graph also being known as a
    <strong>digraph</strong>. A hyperlink on a page is directed, as it takes you to another page when clicked. A choice
    in a gamebook is undirected, as it allows you to choose which path to take next. 
  </li>

  <li>
    A graph can be <strong>cyclic</strong> or <strong>acyclic</strong>; it can contain loops that lead back to previous
    nodes or not. A website is a cyclic graph - you can navigate back to previous pages. Gamebooks, on the other hand,
    are (usually) acyclic graphs, each scene can only be visited once.
  </li>
</ul>

<p>
  To illustrate these concepts, let's look some examples. First, we will use a simple eCommerce website as our graph. 
  The nodes represent the different pages on the website, and the edges represent the links between them:
</p>

<div class="mermaid">
graph TD
  A[Homepage] -->|"Menu link"| B[Products]
  B -->|"View details"| C[Product Details]
  C -->|"Add to cart"| D[Shopping Cart]
  D -->|"Continue shopping"| B
  D -->|"Checkout"| E[Checkout]
  E -->|"Order confirmation"| F[Order Complete]
  F -->|"Return to home"| A
  A -->|"View cart"| D

classDef darkTheme fill:#2e2e2e,stroke:#646cff,stroke-width:2px,color:#ffffff;
class A,B,C,D,E,F darkTheme;
linkStyle default stroke: white;
</div>

<p>
  This forms a <strong>directed cyclic graph</strong> comprising the <code>Products</code>,
  <code>Product Details</code>, <code>Shopping Cart</code> and <code>Checkout</code> nodes. The <code>Homepage</code>
  and <code>Order Complete</code> nodes are part of this cycle as well, allowing users to navigate back to the starting 
  point after completing their purchase.
</p>

<p>
 For our second example, consider this outline of a simple adventure gamebook plot:
</p>

<div class="mermaid">
graph TD
  1[Start Adventure] -->|"Enter forest"| 2[Forest Encounter]
  1 -->|"Visit town"| 3[Town Market]
  2 -->|"Fight monster"| 4[Combat]
  2 -->|"Hide"| 5[Escape]
  3 -->|"Buy weapons"| 6[Armory]
  3 -->|"Get information"| 7[Tavern]
  4 -->|"Victory"| 8[Treasure]
  5 -->|"Continue journey"| 9[Mountain Path]
  6 -->|"Test weapon"| 4
  7 -->|"Learn secret"| 9
  8 -->|"Find map"| 10[Final Dungeon]
  9 -->|"Enter castle"| 10
  10 -->|"Face final boss"| 11[Ending]

classDef darkTheme fill:#2e2e2e,stroke:#646cff,stroke-width:2px,color:#ffffff;
class 1,2,3,4,5,6,7,8,9,10,11 darkTheme;
linkStyle default stroke: white;
</div>

<p>
  This is a <strong>directed acyclic graph (DAG)</strong>. The player can start their adventure by entering the forest
  or visiting the town. Each choice leads to different encounters and outcomes, but once a path is chosen, it cannot be
  revisited. The player must navigate through the nodes, making decisions that affect the flow of the story. The edges 
  represent the choices made by the player, leading them to different nodes based on their decisions.
</p>

<p>
  Gamebooks and adventure modules tend to mostly use DAGs to prevent infinite loops, though some may include cycles for
  specific gameplay mechanics. Published adventure modules and homebrewed adventures for table top RPGs like 
  <i>Dungeons &amp; Dragons</i>, are often written in a similar way. They typically consist of a series of 
  interconnected nodes that guide players through the narrative. Whether the graph is cyclic, and what direction it 
  takes, depends on the choices made by the players and how the Dungeon Master weaves those choices into the narrative. 
  The variety of formats such adventures can take is limitless, but a few common structures have emerged over the 
  years. One such, which allows for an almost endless number of adventures to be created, is the Five Room Dungeon.
</p>

<h2>Five Room Dungeons</h2>

<p>
  The Five Room Dungeon is a popular structure for creating adventure modules in tabletop role-playing games. It is
  designed to provide a balanced and engaging experience for players, with a focus on exploration, combat, and
  problem-solving. The structure consists of five rooms or encounters, each with its own purpose and challenges. The
  five rooms are:
</p>

<ul>
  <li>
    <strong>Room 1: Entrance and Guardian</strong> - This encounter introduces the players to the adventure and sets 
    the stage for the challenges ahead. It often includes a guardian or obstacle that must be overcome to proceed. For
    example, a lone goblin sits asleep at the entrance to a cave, allowing for the players to sneak past, ambush it or
    try to talk their way past it.
  </li>

  <li>
    <strong>Room 2: Puzzle or Roleplaying Challenge</strong> - This encounter presents a puzzle or roleplaying
    challenge that requires players to think creatively and work together to solve it. For example, a riddle
    is written on the wall of a room containing a treasure chest, which can only be opened by solving the 
    riddle and saying the answer aloud.
  </li>

  <li>
    <strong>Room 3: Red Herring, Trick or Setback</strong> - This encounter introduces a twist or setback that
    complicates the players' progress. For example, the players find a treasure chest, but when they try to open it,
    they get bitten by a mimic.
  </li>
  
  <li>
    <strong>Room 4: Climax and Final Challenge</strong> - This encounter presents the ultimate challenge that players
    must face to complete the adventure. For example, a vast cavern home to a dragon sleeping atop a pile of gold.
  </li>

  <li>
    <strong>Room 5: Reward and Conclusion</strong> - This encounter provides the players with a reward for their 
    efforts, wrapping up the adventure and offering closure to the story. Alternatively, it can set the stage for
    future stories with a shocking twist or cliffhanger. For example, the player's leave with the treasure but 
    missed the dragon's eggs, which will hatch in time for the next adventure.
  </li>
</ul>

<p>
  The 'dungeon' can be a literal dungeon, a forest, a town or any other location that fits the adventure, and the
  number of rooms can be anywhere from five to thousands. While the structure is designed around five encounters, 
  additional ones or rooms can be added depending on the needs of the story. The encounters can take place in one 
  location or span multiple, and they can be approached in a number of different ways.
</p>

<p>
  The nodes, specifically the geographical ones, represent an interesting challenge for the Dungeon Master. They
  must create a map that allows players to navigate the encounters in a way that makes sense and is engaging. The
  rooms can be connected with passageways, secret tunnels, teleportation circles or by any number of other means. They
  can be locked behind doors or easily accessible, and the design of these connections can greatly influence the flow
  of the adventure.
</p>

<p>
  Interestingly, if the adventure is a literal five room dungeon, then we know thanks to the research of 
  <a href="https://enac.hal.science/hal-03097484/document" target="_blank">Steve Lawford</a> that the rooms can be 
  joined in one of 21 different ways: 
</p>

<img src="assets/lawford-five-node-subgraphs.png" alt="Five Room Dungeon Node Connections" />

<p>
  With 21 different ways to connect locations and a near infinite number of variations on the encounters, the Five Room
  Dungeon is a flexible and adaptable structure that can be used to create a wide range of adventures, and offers an 
  a fascinating glimpse into the complexities that can arise from linking nodes together.  
</p>

<h2>Implementing a Five Room Dungeon Gamebook</h2>

<p>
  To wrap up this chapter, let's implement a simple gamebook using the concepts we have discussed. We will create a
  simple adventure gamebook using TypeScript, which will allow players to navigate through the nodes and make choices
  that affect the outcome of the story. 
</p>

<p>
  In terms of a gamebook, we can think of the nodes as resembling something like this:
</p>

<pre><code class="language-typescript">interface Choice {
  text: string;
  nextNodeId: number;
}

interface AdventureNode {
  id: number;
  text: string;
  choices: Choice[];
  isEnding: boolean;
}</code></pre>

<p>
  Each node is made up of a unique ID to identify it; a text description of the scene; a list of choices that
  the player can make and a boolean value indicating whether the node is an ending point in the narrative. The
  <code>choices</code> property is an array of <code>Choice</code> objects, each containing a text description of the
  choice and the ID of the next node that the player will be taken to if they select that choice. The edges are the 
  connections between nodes, representing the choices that players can make. Each choice leads to a different node,
  creating a branching structure that allows for multiple paths through the narrative. The direction of the edges 
  indicates the flow of the story, guiding players from one node to another based on their decisions.
</p>

<p>
  We can then create an adventure graph to store all the nodes and handle the navigation between them:
</p>

<pre><code class="language-typescript">class AdventureGraph {
  private nodes: Map&lt;number, AdventureNode&gt; = new Map();
  private currentNodeId: number;

  constructor(startingNodeId: number) {
    this.currentNodeId = startingNodeId;
  }

  addNode(node: AdventureNode): void {
    this.nodes.set(node.id, node);
  }

  getCurrentNode(): AdventureNode | undefined {
    return this.nodes.get(this.currentNodeId);
  }

  makeChoice(choiceId: number): boolean {
    const currentNode = this.getCurrentNode();
    const choiceIds = currentNode?.choices.map(choice => choice.nextNodeId)
    if (!currentNode || !choiceIds?.includes(choiceId)) {
      return false;
    }

    this.currentNodeId = choiceId;
    return true;
  }

  isAtEnding(): boolean {
    const currentNode = this.getCurrentNode();
    return currentNode ? currentNode.isEnding : false;
  }

  private validateChoice(choice: Choice, node: AdventureNode): boolean {
    if (!this.nodes.has(choice.nextNodeId)) {
      console.error(
        `Node ${node.id} has invalid choice to ${choice.nextNodeId}`
      );
      return false;
    }
    return true;
  }

  validateGraph(): boolean {
    for (const node of this.nodes.values()) {
      for (const choice of node.choices) {
        if (!this.validateChoice(choice, node)) return false;
      }
    }
    return true;
  }
}</code></pre>

<p>
  This class allows you to create an adventure graph, add nodes to it, and navigate through the nodes based on
  player choices. The <code>validateGraph</code> method checks that all choices lead to valid nodes, ensuring the
  integrity of the graph. This is important for ensuring that players can only make valid choices and that the
  narrative flows correctly. It also helps to prevent errors or inconsistencies in the game, such as leading players
  to dead ends or invalid states. By validating the graph, you can ensure that the game is playable and that players
  can progress through the story without encountering any issues.
</p>
